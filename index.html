<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Movies</title>
<style>
*{box-sizing:border-box}
body{margin:0;font-family:Arial,sans-serif;background:#141414;color:#fff}
header{background:#141414;padding:15px;display:flex;align-items:center;position:sticky;top:0;z-index:10}

#settingsBtn {
  background: none;
  border: none;
  color: #aaa;
  font-size: 24px;
  cursor: pointer;
  margin-left: auto;
  padding: 0 15px;
  transition: color 0.3s;
}
#settingsBtn:hover { color: white; }

header h1{color:#e50914;margin:0;font-size:18px}
.search-container{position:relative;display:inline-block}
input[type="text"]{padding:10px 35px 10px 15px;font-size:16px;width:200px;border-radius:25px;border:2px solid #333;background:#222;color:#fff;outline:none;transition:border-color 0.3s}
input[type="text"]:focus{border-color:#e50914}
.search-container::before{content:'üîç';position:absolute;right:15px;top:50%;transform:translateY(-50%);color:#999;font-size:18px}
.dropdown{position:absolute;top:100%;left:0;right:0;background:#333;border:1px solid #555;max-height:200px;overflow-y:auto;z-index:1000;display:none}
.dropdown-item{padding:8px;cursor:pointer;border-bottom:1px solid #444;display:flex;align-items:center;gap:10px}
.dropdown-item:hover{background:#555}
.dropdown-item.selected{background:#e50914;color:#fff}
.dropdown-item mark{background:#ff6b35;color:#fff;padding:1px 2px;border-radius:2px}
.dropdown-item-img {
  width: 40px;
  height: 60px;
  object-fit: cover;
  border-radius: 4px;
  flex-shrink: 0;
  background-color: #222;
}
.dropdown-item-info {
  overflow: hidden; /* To make text-overflow work */
}
.dropdown-item-title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-weight: bold;
  display: block; /* Ensure it takes full width */
}
section{margin-top:15px}
h2{margin-left:10px;font-size:16px}
.carousel-wrapper{position:relative}
.carousel{display:flex;overflow-x:auto;gap:8px;padding:15px;scroll-behavior:smooth;cursor:grab}
.carousel::-webkit-scrollbar{display:none}
.movie-card{min-width:120px;cursor:pointer;position:relative;transition:transform .2s;flex-shrink:0}
.movie-card img{width:100%;border-radius:6px;display:block}
.movie-title{position:absolute;bottom:3px;left:3px;right:3px;background:rgba(0,0,0,.7);padding:1px 3px;font-size:12px;border-radius:4px;text-align:center}
.preview-card{display:none!important}
.loader{width:50px;height:50px;border:5px solid #333;border-bottom-color:#e50914;border-radius:50%;display:inline-block;box-sizing:border-box;animation:rotation 1s linear infinite;margin:20px auto;display:none}
@keyframes rotation{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
.movie-card img:before {
  content: ' ';
  display: block;
  position: absolute;
  height: 100%;
  width: 100%;
  background-color: #222;
  color: #666;
  text-align: center;
  font-size: 14px;
  line-height: 225px; /* Approximate vertical center */
}
.arrow{display:none} /* hide arrows on mobile */

/* Movie Details Modal Styles */
.movie-details-modal {
  visibility: hidden;
  opacity: 0;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.85);
  overflow-y: auto;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

.movie-details-modal.modal-open {
  visibility: visible;
  opacity: 1;
}

.movie-details-content {
  background-color: #1a1a1a;
  margin: 5% auto;
  padding: 20px;
  border: 1px solid #333;
  border-radius: 8px;
  width: 90%;
  max-width: 800px;
  color: white;
  max-height: 90vh;
  overflow-y: auto;
  transform: scale(0.95);
  transition: transform 0.3s ease;
}

.modal-open .movie-details-content {
  transform: scale(1);
}

.movie-details-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.movie-details-header h3 {
  margin: 0;
  color: #e50914;
  font-size: 24px;
}

.close-details-modal {
  color: #aaa;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}

.close-details-modal:hover {
  color: white;
}

.movie-details-body {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
}

.movie-poster {
  flex: 0 0 200px;
}

.movie-poster img {
  width: 100%;
  border-radius: 8px;
}

.movie-info {
  flex: 1;
  min-width: 300px;
}

.movie-overview {
  margin-bottom: 20px;
  line-height: 1.6;
}

.watch-now-btn {
  background: #e50914;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 6px;
  font-size: 16px;
  cursor: pointer;
  margin-bottom: 20px;
  transition: background-color 0.3s;
}

.watch-now-btn:hover {
  background: #f40612;
}

.movie-meta {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin-bottom: 20px;
}

.meta-item {
  background: #333;
  padding: 10px;
  border-radius: 6px;
}

.meta-item strong {
  color: #e50914;
}

.cast-list {
  margin-top: 20px;
}

.cast-list h4 {
  color: #e50914;
  margin-bottom: 10px;
}

.cast-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 10px;
}

.cast-member {
  text-align: center;
}

.cast-member img {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  object-fit: cover;
  margin-bottom: 5px;
}

.cast-member p {
  margin: 0;
  font-size: 12px;
  line-height: 1.2;
}

/* Provider Modal Button Styles */
.provider-btn {
  background: #333;
  color: white;
  border: 1px solid #555;
  padding: 12px 24px;
  border-radius: 6px;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s, border-color 0.3s;
}

.provider-btn:hover {
  background: #e50914;
  border-color: #e50914;
}

/* Fullscreen button for video player */
.fullscreen-btn {
    background: #444;
    color: white;
    border: 1px solid #666;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    margin-left: auto; /* Pushes it to the right */
    margin-right: 20px; /* Space from the close button */
    transition: background-color 0.3s;
}

.favorite-btn {
  background: #555;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 6px;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.clear-fav-btn {
  background: #333;
  color: #aaa;
  border: 1px solid #555;
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s, color 0.3s;
}
.clear-fav-btn:hover {
    background: #e50914;
    color: white;
}

/* Preview Card Styles */
.preview-card {
  position: absolute;
  z-index: 20;
  background-color: #1a1a1a;
  border-radius: 8px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  width: 280px; /* Larger than the base card */
  transform-origin: center;
  transition: transform 0.2s ease-out, opacity 0.2s ease-out;
  opacity: 0;
  transform: scale(0.95);
  pointer-events: none; /* Hidden by default */
  overflow: hidden;
}

.preview-card.visible {
  opacity: 1;
  transform: scale(1);
  pointer-events: auto; /* Clickable when visible */
}

.preview-card-image {
  width: 100%;
  height: 160px;
  object-fit: cover;
  display: block;
}

.preview-card-info {
  padding: 15px;
}

.preview-card-title {
  font-size: 18px;
  font-weight: bold;
  margin: 0 0 10px 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.preview-card-actions {
  display: flex;
  gap: 10px;
}

.preview-action-btn {
  flex-grow: 1;
  padding: 8px 12px;
  font-size: 14px;
  border-radius: 4px;
  border: 1px solid #555;
  background: #333;
  color: white;
  cursor: pointer;
}

/* Back to Top Button */
#backToTopBtn {
  display: none;
  position: fixed;
  bottom: 20px;
  right: 30px;
  z-index: 99;
  border: none;
  outline: none;
  background-color: #e50914;
  color: white;
  cursor: pointer;
  padding: 12px 15px;
  border-radius: 50%;
  font-size: 20px;
  line-height: 1;
  transition: background-color 0.3s;
}

/* Settings Panel Styles */
.settings-list {
  list-style: none;
  padding: 0;
  margin: 0;
}
.settings-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 0;
  border-bottom: 1px solid #333;
}
</style>
<script>
// IMPORTANT: Replace this with your own Cloudflare Worker URL after deploying it.
const WORKER_URL = 'https://movielist.22afed28-f0b2-46d0-8804-c90e25c90bd4.workers.dev/';
</script>
</head>
<body>
<header>
  <h1>Movies</h1>
  <button id="settingsBtn" title="Settings">‚öôÔ∏è</button>
  <div class="search-container">
    <input type="text" id="search" placeholder="Search...">
  </div>
</header>

<section id="favoritesSection" style="margin: 20px; display: none;">
  <div style="display: flex; justify-content: space-between; align-items: center; padding: 0 10px;">
    <h2 style="color: white; margin: 0;">My Favorites</h2>
    <button id="clearFavoritesBtn" class="clear-fav-btn">Clear All</button>
  </div>
  <div id="favoritesGrid" style="display: flex; overflow-x: auto; gap: 10px; padding: 15px; scroll-behavior: smooth;">
    <!-- Favorite items will be rendered here -->
  </div>
</section>

<section>
</section>

<section id="mostPopularMovies" style="margin: 20px;">
  <h2 style="color: white; margin-left: 10px;">Most Popular Movies</h2>
  <div id="popularMoviesGrid" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; min-height: 200px;"></div>
  <div id="popularMoviesLoader" style="text-align: center; padding: 20px;">
      <div class="loader"></div>
  </div>
</section>

<section id="mostPopularTvShows" style="margin: 20px;">
  <h2 style="color: white; margin-left: 10px;">Most Popular TV Shows</h2>
  <div id="popularTvShowsGrid" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; min-height: 200px;"></div>
  <div id="popularTvShowsLoader" style="text-align: center; padding: 20px;">
      <div class="loader"></div>
  </div>
</section>

<script>
function createMovieCard(movie) {
  const card = document.createElement('div');
  card.style.width = '150px';
  card.style.position = 'relative';
  card.style.cursor = 'pointer';

  // Correctly access the poster URL from the movie object
  const posterUrl = movie.poster_path ? `https://image.tmdb.org/t/p/w500${movie.poster_path}` : ''; // Use movie.name for TV shows

  const img = document.createElement('img');
  img.src = posterUrl && posterUrl !== "N/A" ? posterUrl : 'https://placehold.co/150x225/1a1a1a/444?text=No+Image';
  img.alt = movie.title || 'Movie Poster';
  img.style.width = '100%';
  img.loading = 'lazy'; // Improve performance by lazy loading images
  img.style.borderRadius = '6px';
  img.style.display = 'block';

  card.appendChild(img);

  const titleDiv = document.createElement('div');
  titleDiv.textContent = movie.title || movie.name || ''; // Use movie.name for TV shows
  titleDiv.style.position = 'absolute';
  titleDiv.style.bottom = '5px';
  titleDiv.style.left = '5px';
  titleDiv.style.right = '5px';
  titleDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
  titleDiv.style.color = 'white';
  titleDiv.style.fontSize = '12px';
  titleDiv.style.padding = '2px 4px';
  titleDiv.style.borderRadius = '4px';
  titleDiv.style.textAlign = 'center';

  card.appendChild(titleDiv);

  // Attach movie data to the card element for easy access on hover
  card.movieData = movie;

  // Add click handler to show movie details
  card.onclick = () => {
    showMovieDetails(movie.id, movie.media_type || 'movie'); // Pass the correct media_type
  };

  return card;
}


// --- Favorites Functionality ---

// Get favorites from localStorage
function getFavorites() {
  return JSON.parse(localStorage.getItem('favorites') || '[]');
}

// Save favorites to localStorage
function saveFavorites(favorites) {
  localStorage.setItem('favorites', JSON.stringify(favorites));
}

// Render the favorites list on the page
function renderFavorites() {
  const favorites = getFavorites();
  const favoritesSection = document.getElementById('favoritesSection');
  const favoritesGrid = document.getElementById('favoritesGrid');
  favoritesGrid.innerHTML = '';

  if (favorites.length > 0) {
    favoritesSection.style.display = 'block';
    favorites.forEach(item => {
      const card = createMovieCard(item);
      favoritesGrid.appendChild(card);
    });
  } else {
    favoritesSection.style.display = 'none';
  }
}

// Toggle favorite status
function toggleFavorite(item) {
  let favorites = getFavorites();
  const existingIndex = favorites.findIndex(fav => fav.id === item.id);

  if (existingIndex > -1) {
    // Remove from favorites
    favorites.splice(existingIndex, 1);
  } else {
    // Add to favorites
    favorites.push(item);
  }

  saveFavorites(favorites);
  renderFavorites(); // Update the UI

  // Also update the button in the details modal if it's open
  const favButton = document.getElementById('favoriteBtn');
  if (favButton) {
    updateFavoriteButton(item.id);
  }
}

// Update the favorite button's appearance and text
function updateFavoriteButton(tmdbId) {
  const favorites = getFavorites();
  const isFav = favorites.some(fav => fav.id === tmdbId);
  const favButton = document.getElementById('favoriteBtn');
  favButton.textContent = isFav ? 'Remove from Favorites' : 'Add to Favorites';
  favButton.style.background = isFav ? '#f40612' : '#555';
}

// Clear all favorites from localStorage
function clearFavorites() {
  if (confirm('Are you sure you want to clear all your favorites? This cannot be undone.')) {
    localStorage.removeItem('favorites');
    renderFavorites();
  }
}

class InfiniteScroll {
  constructor({ gridId, loaderId, mediaType }) {
    this.grid = document.getElementById(gridId);
    this.loader = document.getElementById(loaderId);
    this.mediaType = mediaType;

    this.currentPage = 1;
    this.totalPages = Infinity;
    this.isLoading = false;

    if (!this.grid || !this.loader) {
      console.error(`InfiniteScroll: Grid or Loader element not found for ${gridId}/${loaderId}`);
      return;
    }

    this.init();
  }

  init() {
    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting && !this.isLoading) {
        this.fetchAndRender();
      }
    }, { rootMargin: '0px 0px 400px 0px' });

    observer.observe(this.loader);
    this.fetchAndRender(); // Initial fetch
  }

  async fetchAndRender() {
    if (this.isLoading || this.currentPage > this.totalPages) return;

    this.isLoading = true;
    this.loader.querySelector('.loader').style.display = 'block';

    try {
      const response = await fetch(`${WORKER_URL}?popular=true&media_type=${this.mediaType}&page=${this.currentPage}`);
      if (!response.ok) throw new Error(`Failed to fetch popular ${this.mediaType} list.`);

      const data = await response.json();
      this.totalPages = data.total_pages;

      data.results.forEach(item => {
        if (item.id && item.poster_path) {
          this.grid.appendChild(createMovieCard({ ...item, media_type: this.mediaType }));
        }
      });

      this.currentPage++;
    } catch (error) {
      console.error(`Failed to load popular ${this.mediaType}:`, error);
    } finally {
      this.isLoading = false;
      if (this.currentPage > this.totalPages) this.loader.style.display = 'none';
    }
  }
}

// --- Settings Panel Functionality ---

const settingsConfig = {
  showFavorites: { elementId: 'favoritesSection', checkboxId: 'settingShowFavorites', defaultValue: true },
  showPopularMovies: { elementId: 'mostPopularMovies', checkboxId: 'settingShowPopularMovies', defaultValue: true },
  showPopularTvShows: { elementId: 'mostPopularTvShows', checkboxId: 'settingShowPopularTvShows', defaultValue: true }
};

let userSettings = {};

function loadSettings() {
  const savedSettings = JSON.parse(localStorage.getItem('userSettings') || '{}');
  for (const key in settingsConfig) {
    userSettings[key] = savedSettings[key] ?? settingsConfig[key].defaultValue;
  }
}

function saveSettings() {
  localStorage.setItem('userSettings', JSON.stringify(userSettings));
}

function applySettings() {
  for (const key in settingsConfig) {
    const config = settingsConfig[key];
    const element = document.getElementById(config.elementId);
    const checkbox = document.getElementById(config.checkboxId);

    if (element) {
      // The favorites section has its own display logic based on content, so we respect that.
      if (key === 'showFavorites') {
        if (userSettings[key]) {
          renderFavorites(); // This function will handle showing/hiding the section.
        } else {
          element.style.display = 'none';
        }
      } else {
        element.style.display = userSettings[key] ? 'block' : 'none';
      }
    }
    if (checkbox) {
      checkbox.checked = userSettings[key];
    }
  }
}

function openSettingsPanel() {
  document.getElementById('settingsPanel').classList.add('modal-open');
}

function closeSettingsPanel() {
  document.getElementById('settingsPanel').classList.remove('modal-open');
}

function handleSettingChange(key, isChecked) {
  userSettings[key] = isChecked;
  saveSettings();
  applySettings();
}

document.addEventListener('DOMContentLoaded', () => {
  // Initialize infinite scroll for movies and TV shows
  new InfiniteScroll({ gridId: 'popularMoviesGrid', loaderId: 'popularMoviesLoader', mediaType: 'movie' });
  new InfiniteScroll({ gridId: 'popularTvShowsGrid', loaderId: 'popularTvShowsLoader', mediaType: 'tv' });

  renderFavorites(); // Render favorites on page load

  // Add event listener for the clear favorites button
  document.getElementById('clearFavoritesBtn').addEventListener('click', clearFavorites);

  // Setup hover previews for all grids
  setupHoverPreviews();

  // Load and apply user settings
  loadSettings();
  applySettings();

  // Wire up settings panel events
  document.getElementById('settingsBtn').addEventListener('click', openSettingsPanel);
  for (const key in settingsConfig) {
    document.getElementById(settingsConfig[key].checkboxId).addEventListener('change', (e) => handleSettingChange(key, e.target.checked));
  }
});
</script>

<script>
// Enhanced search functionality with debouncing, caching, and keyboard navigation
class SearchManager {
  constructor() {
    this.searchInput = document.getElementById('search');
    this.dropdown = null;
    this.debounceTimer = null;
    this.cache = new Map();
    this.selectedIndex = -1;
    this.searchResults = [];
    this.isLoading = false;

    this.init();
  }

  init() {
    this.createDropdown();
    this.bindEvents();
  }

  createDropdown() {
    if (this.dropdown) return;

    this.dropdown = document.createElement('div');
    this.dropdown.className = 'dropdown';
    this.dropdown.setAttribute('role', 'listbox');
    this.dropdown.setAttribute('aria-label', 'Search results');
    this.dropdown.style.display = 'none';

    const searchContainer = document.querySelector('.search-container');
    searchContainer.appendChild(this.dropdown);
  }

  bindEvents() {
    // Debounced input handler
    this.searchInput.addEventListener('input', (e) => {
      this.handleInput(e.target.value);
    });

    // Keyboard navigation
    this.searchInput.addEventListener('keydown', (e) => {
      this.handleKeydown(e);
    });

    // Focus/blur handlers
    this.searchInput.addEventListener('focus', () => {
      if (this.searchResults.length > 0) {
        this.showDropdown();
      }
    });

    this.searchInput.addEventListener('blur', () => {
      // Delay hiding to allow dropdown clicks
      setTimeout(() => {
        if (!this.dropdown.contains(document.activeElement)) {
          this.hideDropdown();
        }
      }, 150);
    });

    // Dropdown click handler
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('dropdown-item')) {
        this.handleDropdownItemClick(e.target);
      } else if (!document.querySelector('.search-container').contains(e.target)) {
        this.hideDropdown();
      }
    });
  }

  handleInput(value) {
    const query = value.trim();

    // Clear previous timer
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }

    // Hide dropdown for short queries or empty input
    if (!query || query.length < 2) {
      this.hideDropdown();
      this.isLoading = false;
      return;
    }

    // Show loading state
    this.showLoadingState();

    // Debounce search requests
    this.debounceTimer = setTimeout(() => {
      this.performSearch(query);
    }, 300);
  }

  async performSearch(query) {
    // Check cache first
    if (this.cache.has(query)) {
      this.displayResults(this.cache.get(query));
      return;
    }

    this.isLoading = true;

    try {
      console.log('Searching for:', query);

      // Use our new worker for all searches
      const response = await fetch(`${WORKER_URL}?query=${encodeURIComponent(query)}`);
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      const data = await response.json();
      console.log('Worker search results:', data);

      if (data.results && data.results.length > 0) {
        // Convert TMDB multi-search results to the format our dropdown expects
        const formattedResults = data.results.filter(item => item.media_type !== 'person').map(item => ({
          Title: item.title || item.name,
          Year: (item.release_date || item.first_air_date) ? (item.release_date || item.first_air_date).substring(0, 4) : '',
          imdbID: item.id.toString(), // TMDB ID, will fetch IMDb ID on click
          Type: item.media_type, // movie, tv, etc.
          Poster: item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : '',
        }));
        this.cache.set(query, formattedResults);
        this.displayResults(formattedResults);
      } else {
        this.showNoResults();
      }
    } catch (error) {
      console.error('Search error:', error);
      this.showErrorState(`Search failed: ${error.message}`);
    } finally {
      this.isLoading = false;
    }
  }

  displayResults(results) {
    this.searchResults = results.slice(0, 5); // Limit to 5 results
    this.selectedIndex = -1;

    if (this.searchResults.length === 0) {
      this.showNoResults();
      return;
    }

    this.dropdown.innerHTML = this.searchResults.map((result, index) => {
      const posterUrl = result.Poster ? result.Poster.replace('w500', 'w92') : 'https://placehold.co/40x60/1a1a1a/444?text=N/A';
      return `
        <div class="dropdown-item" data-imdb="${result.imdbID}" data-type="${result.Type}" data-index="${index}" role="option" aria-selected="false">
          <img src="${posterUrl}" class="dropdown-item-img" alt="Poster">
          <div class="dropdown-item-info">
            <span class="dropdown-item-title">${this.highlightQuery(result.Title)}</span>
            <span style="font-size: 12px; color: #aaa;">${result.Year} &middot; ${result.Type}</span>
          </div>
        </div>`;
    }).join('');

    this.showDropdown();
  }

  highlightQuery(text) {
    const query = this.searchInput.value.trim();
    if (!query || query.length < 2) return text;

    const regex = new RegExp(`(${query})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }

  showLoadingState() {
    this.dropdown.innerHTML = '<div class="dropdown-item" style="text-align: center; color: #999;">Searching...</div>';
    this.dropdown.style.display = 'block';
  }

  showErrorState(message) {
    this.dropdown.innerHTML = `<div class="dropdown-item" style="text-align: center; color: #e50914;">${message}</div>`;
    this.dropdown.style.display = 'block';
  }

  showNoResults() {
    const query = this.searchInput.value.trim();
    this.dropdown.innerHTML = `<div class="dropdown-item" style="text-align: center; color: #999;">No results for "${query}"</div>`;
    this.dropdown.style.display = 'block';
  }

  showDropdown() {
    this.dropdown.style.display = 'block';
    this.searchInput.setAttribute('aria-expanded', 'true');
  }

  hideDropdown() {
    this.dropdown.style.display = 'none';
    this.searchInput.setAttribute('aria-expanded', 'false');
    this.selectedIndex = -1;
  }

  handleKeydown(e) {
    if (this.searchResults.length === 0) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        this.selectedIndex = Math.min(this.selectedIndex + 1, this.searchResults.length - 1);
        this.updateSelection();
        break;

      case 'ArrowUp':
        e.preventDefault();
        this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
        this.updateSelection();
        break;

      case 'Enter':
        e.preventDefault();
        if (this.selectedIndex >= 0) {
          const selectedItem = this.dropdown.querySelector(`[data-index="${this.selectedIndex}"]`);
          this.handleDropdownItemClick(selectedItem);
        } else {
          // Perform search with current input
          this.handleEnterKey();
        }
        break;

      case 'Escape':
        e.preventDefault();
        this.hideDropdown();
        this.searchInput.blur();
        break;
    }
  }

  updateSelection() {
    const items = this.dropdown.querySelectorAll('.dropdown-item');

    items.forEach((item, index) => {
      if (index === this.selectedIndex) {
        item.classList.add('selected');
        item.setAttribute('aria-selected', 'true');
        item.scrollIntoView({ block: 'nearest' });
      } else {
        item.classList.remove('selected');
        item.setAttribute('aria-selected', 'false');
      }
    });
  }

  async handleDropdownItemClick(item) {
    const tmdbId = item.dataset.imdb; // This is the TMDB ID from the search result (data-imdb is a misnomer here)
    const type = item.dataset.type;

    // Show movie details for the selected item
    showMovieDetails(tmdbId, type);
    this.hideDropdown();
    this.searchInput.value = '';
  }

  async handleEnterKey() {
    const query = this.searchInput.value.trim();
    if (!query) return;

    // Just trigger a new search and let the user pick from the dropdown
    try {
      this.performSearch(query);
    } catch (error) {
      console.error('Enter key search error:', error);
      this.showErrorState("Search failed. Please try again.");
    }
  }

  // Cleanup method
  destroy() {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    if (this.dropdown && this.dropdown.parentNode) {
      this.dropdown.parentNode.removeChild(this.dropdown);
    }
  }
}

// Initialize search manager when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  window.searchManager = new SearchManager();
});
</script>

<!-- Movie Details Modal -->
<div id="movieDetailsModal" class="movie-details-modal">
  <div class="movie-details-content">
    <div class="movie-details-header">
      <h3 id="detailsTitle">Movie Details</h3>
      <span class="close-details-modal" id="closeDetailsModal">&times;</span>
    </div>
    <div id="movieDetailsBody" class="movie-details-body">
      <!-- Movie details will be populated here -->
    </div>
  </div>
</div>

<!-- Settings Panel Modal -->
<div id="settingsPanel" class="movie-details-modal">
  <div class="movie-details-content" style="max-width: 500px;">
    <div class="movie-details-header">
      <h3>Settings</h3>
      <span class="close-details-modal" onclick="closeSettingsPanel()">&times;</span>
    </div>
    <ul class="settings-list">
      <li class="settings-item">
        <label for="settingShowFavorites">Show "My Favorites"</label>
        <input type="checkbox" id="settingShowFavorites">
      </li>
      <li class="settings-item">
        <label for="settingShowPopularMovies">Show "Popular Movies"</label>
        <input type="checkbox" id="settingShowPopularMovies">
      </li>
      <li class="settings-item">
        <label for="settingShowPopularTvShows">Show "Popular TV Shows"</label>
        <input type="checkbox" id="settingShowPopularTvShows">
      </li>
    </ul>
  </div>
</div>

<!-- Video Player Modal -->
<div id="videoPlayerModal" class="movie-details-modal">
  <div class="movie-details-content" style="width: 100%; height: 100%; max-width: none; margin: 0; padding: 0; background: black; border-radius: 0;">
    <div class="movie-details-header" style="padding: 10px 20px; background: #1a1a1a;">
      <h3 id="videoPlayerTitle">Now Playing</h3>
      <button class="fullscreen-btn" onclick="toggleFullScreen()">Fullscreen</button>
      <span class="close-details-modal" onclick="closeVideoPlayerModal()">&times;</span>
    </div>
    <iframe id="videoPlayerFrame" style="width: 100%; height: calc(100% - 52px); border: none;" allowfullscreen></iframe>
  </div>
</div>


<script defer>
// Show movie details modal
async function showMovieDetails(tmdbId, type) {
  const modal = document.getElementById('movieDetailsModal');
  const detailsTitle = document.getElementById('detailsTitle');
  const detailsBody = document.getElementById('movieDetailsBody');

  // Show modal with loading state immediately
  detailsTitle.textContent = 'Loading...';
  detailsBody.innerHTML = '<div class="loader" style="display: block; margin: 50px auto;"></div>';
  modal.classList.add('modal-open');

  try {
    // Fetch movie details and credits in parallel
    const [detailsResponse, creditsResponse] = await Promise.all([
      fetch(`${WORKER_URL}?details=${tmdbId}&type=${type}`),
      fetch(`${WORKER_URL}?credits=${tmdbId}&type=${type}`)
    ]);

    if (!detailsResponse.ok || !creditsResponse.ok) {
      throw new Error('Failed to retrieve movie data from the server.');
    }

    const details = await detailsResponse.json();
    const credits = await creditsResponse.json();

    // Set modal title
    detailsTitle.textContent = details.title || details.name;

    // Build movie details HTML
    const posterUrl = details.poster_path ? `https://image.tmdb.org/t/p/w500${details.poster_path}` : 'https://placehold.co/300x450/1a1a1a/444?text=No+Image';

    const releaseDate = details.release_date || details.first_air_date;
    const runtime = details.runtime ? `${details.runtime} min` : (details.episode_run_time && details.episode_run_time.length > 0 ? `${details.episode_run_time[0]} min per episode` : 'N/A');
    const genres = details.genres ? details.genres.map(g => g.name).join(', ') : 'N/A';

    const director = credits.crew ? credits.crew.find(c => c.job === 'Director')?.name || 'N/A' : 'N/A';
    const cast = credits.cast ? credits.cast.slice(0, 10) : [];

    // Prepare a simplified item object for favorites
    const favoriteItem = {
      id: details.id,
      title: details.title,
      name: details.name,
      poster_path: details.poster_path,
      media_type: type
    };

    detailsBody.innerHTML = `
      <div class="movie-poster">
        <img src="${posterUrl}" alt="${details.title || details.name}">
      </div>
      <div class="movie-info">
        <button class="watch-now-btn" onclick="watchNow('${tmdbId}', '${type}', '${(details.title || details.name).replace(/'/g, "\\'")}')">Watch Now</button>
        <button id="favoriteBtn" class="favorite-btn" onclick='toggleFavorite(${JSON.stringify(favoriteItem)})'>Add to Favorites</button>
        <div class="movie-overview">${details.overview || 'No overview available.'}</div>
        <div class="movie-meta">
          <div class="meta-item"><strong>Release Date:</strong> ${releaseDate || 'N/A'}</div>
          <div class="meta-item"><strong>Runtime:</strong> ${runtime}</div>
          <div class="meta-item"><strong>Genres:</strong> ${genres}</div>
          <div class="meta-item"><strong>Rating:</strong> ${details.vote_average ? details.vote_average.toFixed(1) : 'N/A'}</div>
          <div class="meta-item"><strong>Director:</strong> ${director}</div>
        </div>
        <div class="cast-list">
          <h4>Cast</h4>
          <div class="cast-grid">
            ${cast.map(actor => `
              <div class="cast-member">
                <img src="${actor.profile_path ? `https://image.tmdb.org/t/p/w185${actor.profile_path}` : 'https://placehold.co/80x80/333/666?text=No+Image'}" alt="${actor.name}">
                <p><strong>${actor.name}</strong></p>
                <p>${actor.character}</p>
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;

    // Update favorite button state after rendering
    updateFavoriteButton(details.id);
  } catch (error) {
    console.error('Error fetching movie details:', error);
    // Display error inside the modal
    detailsTitle.textContent = 'Error';
    detailsBody.innerHTML = `<div style="text-align: center; color: #ff8a8a; padding: 20px;">${error.message}<br>Please try again later.</div>`;
  }
}

// Close movie details modal
function closeMovieDetailsModal() {
  const modal = document.getElementById('movieDetailsModal');
  modal.classList.remove('modal-open');
}

// Modal event listeners
document.getElementById('closeDetailsModal').onclick = closeMovieDetailsModal;

// Close modal when clicking outside
document.getElementById('movieDetailsModal').onclick = function(e) {
  if (e.target === this) {
    closeMovieDetailsModal();
  }
};

// Watch Now function - opens video provider selection
async function watchNow(tmdbId, type, title) {
  // Hide the details modal before showing the provider modal
  document.getElementById('movieDetailsModal').classList.remove('modal-open');

  try {
    // Fetch IMDb ID and the list of providers from the worker in parallel
    const [imdbResponse, providersResponse] = await Promise.all([
      fetch(`${WORKER_URL}?tmdb_id=${tmdbId}&type=${type}`),
      fetch(`${WORKER_URL}?action=getProviders`)
    ]);
    
    const imdbData = await imdbResponse.json();
    const providersData = await providersResponse.json();

    if (imdbData.imdb_id && providersData.providers) {
      showVideoProviders(imdbData.imdb_id, type, title, providersData.providers);
    } else if (!imdbData.imdb_id) {
      throw new Error('Could not find video sources for this title.');
    } else {
      throw new Error('Could not load video providers.');
    }
  } catch (error) {
    console.error('Error fetching data for "Watch Now":', error);
    alert('Failed to load video sources. Please try again.');
    document.getElementById('movieDetailsModal').classList.add('modal-open'); // Re-show details on error
  }
}

// Show video provider selection modal
function showVideoProviders(imdbId, type, title, videoProviders) {
  // Create or reuse a simple provider selection modal
  let providerModal = document.getElementById('providerModal');
  if (!providerModal) {
    providerModal = document.createElement('div');
    providerModal.id = 'providerModal';
    providerModal.className = 'movie-details-modal';
    providerModal.innerHTML = `
      <div class="movie-details-content" style="max-width: 500px;">
        <div class="movie-details-header">
          <h3 id="providerModalTitle">Select Provider</h3>
          <span class="close-details-modal" onclick="closeProviderModal()">&times;</span>
        </div>
        <div id="providerButtons" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
          <!-- Provider buttons will be added here -->
        </div>
      </div>
    `;
    document.body.appendChild(providerModal);
  }

  document.getElementById('providerModalTitle').textContent = `Select Provider for ${title}`;

  const providerButtons = document.getElementById('providerButtons');
  providerButtons.innerHTML = videoProviders.map(provider =>
    `<button class="provider-btn" onclick="selectProvider('${provider.domain}', '${imdbId}', '${type}', '${title}', ${provider.sandbox})">${provider.name}</button>`
  ).join('');

  providerModal.classList.add('modal-open');
}

// Select video provider and load video
async function selectProvider(provider, imdbId, type, title, useSandbox) {
  const embedUrl = await generateEmbedUrl(provider, imdbId, type);

  // Hide the provider selection modal
  closeProviderModal();

  if (embedUrl) {
    const videoModal = document.getElementById('videoPlayerModal');
    const videoFrame = document.getElementById('videoPlayerFrame');
    const videoTitle = document.getElementById('videoPlayerTitle');

    // Apply sandbox setting from the worker
    if (useSandbox) {
      videoFrame.setAttribute('sandbox', 'allow-forms allow-pointer-lock allow-same-origin allow-scripts allow-top-navigation');
    } else {
      videoFrame.removeAttribute('sandbox');
    }

    videoTitle.textContent = `Now Playing: ${title}`;
    videoFrame.src = embedUrl;
    videoModal.classList.add('modal-open');

    console.log(`Opened ${title} on ${provider}: ${embedUrl}`);
  } else {
    alert(`Unable to generate embed URL for ${provider}`);
  }
}

// Close provider modal
function closeProviderModal() {
  const modal = document.getElementById('providerModal');
  if (modal) {
    modal.classList.remove('modal-open');
    // When closing the provider modal, always go back to the details modal.
    document.getElementById('movieDetailsModal').classList.add('modal-open');
  }
}

// Close video player modal and stop video
function closeVideoPlayerModal() {
  const modal = document.getElementById('videoPlayerModal');
  if (modal) {
    modal.classList.remove('modal-open');
    document.getElementById('videoPlayerFrame').src = ''; // Stop video playback
    // After closing the video, go back to the provider selection modal
    const providerModal = document.getElementById('providerModal');
    if (providerModal) {
      providerModal.classList.add('modal-open');
    }
  }
}

// Toggle native fullscreen for the video player iframe
function toggleFullScreen() {
  const frame = document.getElementById('videoPlayerFrame');
  if (!document.fullscreenElement) {
    if (frame.requestFullscreen) {
      frame.requestFullscreen();
    }
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }
}

// --- Hover Preview Functionality ---

let previewTimeout = null;
let hidePreviewTimeout = null;
let activePreviewCard = null;

function setupHoverPreviews() {
  const grids = ['favoritesGrid', 'popularMoviesGrid', 'popularTvShowsGrid'];
  grids.forEach(gridId => {
    const grid = document.getElementById(gridId);
    if (grid) {
      grid.addEventListener('mouseenter', handleGridEnter, true);
      grid.addEventListener('mouseleave', handleGridLeave, true);
    }
  });
}

function handleGridEnter(e) {
  const card = e.target.closest('.movie-card');
  if (card && card.movieData) {
    clearTimeout(hidePreviewTimeout); // Cancel any pending hide
    previewTimeout = setTimeout(() => showPreview(card), 500); // Show after a delay
  }
}

function handleGridLeave(e) {
  const card = e.target.closest('.movie-card');
  if (card) {
    clearTimeout(previewTimeout); // Cancel any pending show
    hidePreviewTimeout = setTimeout(() => {
      if (activePreviewCard && !activePreviewCard.matches(':hover')) {
        hidePreview();
      }
    }, 300);
  }
}

function showPreview(card) {
  if (activePreviewCard) {
    hidePreview(); // Hide any existing preview first
  }

  const movie = card.movieData;
  const cardRect = card.getBoundingClientRect();

  const previewCard = document.createElement('div');
  previewCard.className = 'preview-card';
  previewCard.innerHTML = `
    <img src="${movie.poster_path ? `https://image.tmdb.org/t/p/w500${movie.poster_path}` : 'https://placehold.co/280x160/1a1a1a/444?text=No+Image'}" class="preview-card-image" alt="${movie.title || movie.name}">
    <div class="preview-card-info">
      <h3 class="preview-card-title">${movie.title || movie.name}</h3>
      <div class="preview-card-actions">
        <button class="preview-action-btn details-btn">Details</button>
        <button class="preview-action-btn favorite-btn">Favorite</button>
      </div>
    </div>
  `;

  document.body.appendChild(previewCard);
  activePreviewCard = previewCard;

  // Position the preview card
  const top = window.scrollY + cardRect.top + (cardRect.height / 2) - (250 / 2); // 250 is approx preview height
  const left = window.scrollX + cardRect.left + (cardRect.width / 2) - (280 / 2); // 280 is preview width
  previewCard.style.top = `${Math.max(10, top)}px`;
  previewCard.style.left = `${Math.max(10, left)}px`;

  // Add event listeners for buttons
  previewCard.querySelector('.details-btn').onclick = () => showMovieDetails(movie.id, movie.media_type);
  previewCard.querySelector('.favorite-btn').onclick = () => toggleFavorite(movie);

  // Add listener to hide when mouse leaves the preview itself
  previewCard.addEventListener('mouseleave', () => {
      hidePreviewTimeout = setTimeout(hidePreview, 300);
  });
  previewCard.addEventListener('mouseenter', () => clearTimeout(hidePreviewTimeout));

  // Trigger the transition
  requestAnimationFrame(() => previewCard.classList.add('visible'));
}

function hidePreview() {
  if (activePreviewCard) {
    activePreviewCard.classList.remove('visible');
    setTimeout(() => activePreviewCard && activePreviewCard.remove(), 300); // Remove after transition
    activePreviewCard = null;
  }
}

// Generate embed URL for a provider via worker
async function generateEmbedUrl(provider, imdbId, type) {
  try {
    const response = await fetch(`${WORKER_URL}?action=embed&provider=${provider}&imdb_id=${imdbId}&type=${type}`);
    const data = await response.json();
    return data.embedUrl || '';
  } catch (error) {
    console.error('Error generating embed URL:', error);
    return '';
  }
}

// Close modal on Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    closeMovieDetailsModal();
    closeProviderModal();
    closeVideoPlayerModal();
    closeSettingsPanel();
  }
});

// --- Back to Top Button Functionality ---
const backToTopButton = document.getElementById("backToTopBtn");

// When the user scrolls down 300px from the top of the document, show the button
window.onscroll = function() {
  scrollFunction();
};

function scrollFunction() {
  if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
    backToTopButton.style.display = "block";
  } else {
    backToTopButton.style.display = "none";
  }
}

// When the user clicks on the button, scroll to the top of the document
backToTopButton.addEventListener('click', () => {
  window.scrollTo({top: 0, behavior: 'smooth'});
});
</script>

<!-- Back to Top Button -->
<button id="backToTopBtn" title="Go to top">‚Üë</button>

</body>
</html>
